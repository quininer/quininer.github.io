<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <managingEditor>quininer kel</managingEditor>
        <link>https://quininer.github.io</link>
        <title>icebox</title>
        <lastBuildDate>Mon, 20 Apr 2015 04:05:53 -0000</lastBuildDate>
        <description><![CDATA[不知所云]]></description>
        <pubDate>Mon, 20 Apr 2015 04:05:53 -0000</pubDate>
        <generator>rssgen 1.0</generator>
        <copyright>BY-NC-SA 4.0</copyright>
        <language>zh</language>
        <item><author>quininer kel</author><title>wasm-stack-overflow</title><link>https://quininer.github.io/?wasm-stack-overflow</link><description><![CDATA[<h1>WebAssembly StackOverflow</h1>
<h2><em>Mon Apr 30 16:50:47 2018</em></h2>
<p><a href="http://webassembly.org/">WebAssembly</a> 是一個設計運行在瀏覽器上的類彙編語言，
藉助它可以令 C / C++ 之類的語言運行在瀏覽器上，以期得到性能提升。</p>
<p>新功能自然會引入新攻擊面，可以預見 C / C++ 上經常出現的溢出攻擊並不會在 wasm 上消失。</p>
<p>WebAssembly 同常見的彙編有很多不一樣的地方，例如</p>
<ul>
<li>它是一個 <a href="https://docs.google.com/document/d/1CieRxPy3Fp62LQdtWfhymikb_veZI7S9MnuCZw7biII/edit">Stack Machine</a></li>
<li>它使用 <a href="http://webassembly.org/docs/semantics/#linear-memory">Linear Memory</a></li>
<li>指令與線性內存隔離</li>
<li>…</li>
</ul>
<p>因爲第三點，WebAssembly 在一定程度上是 <a href="https://en.wikipedia.org/wiki/Harvard_architecture">Harvard architecture</a>，這爲 wasm 帶來了很大的安全優勢。</p>
<p>指令與數據隔離，使得 ROP、return2libc 之類的技巧不可能，但棧溢出本身仍是可能的。</p>
<p>我們舉個虛構的例子來證明 wasm 棧溢出的可行性</p>
<p>Rust 代碼:</p>
<p>```rust
// ...</p>
<h1>[wasm_bindgen]</h1>
<p>pub fn hash_with_key(key: &amp;str, data: &amp;str) -&gt; u32 {
    let mut val = [0; 32];
    let key = key.as_bytes();
    let data = data.as_bytes();</p>
<pre><code>val[..3].copy_from_slice(&amp;key[..3]);
val[3] = 0x33;
val[4..][..data.len()].copy_from_slice(&amp;data);

js_hash(&amp;val)
</code></pre>
<p>}</p>
<h1>[wasm_bindgen]</h1>
<p>pub fn table_index(i: usize) -&gt; u8 {
    let a = [b'a', b'd', b'c', b'b'];
    unsafe { *a.get_unchecked(i) }
}
```</p>
<p>WebAssembly 的 wat 格式基於 sexp，指令精簡，與傳統彙編相比，相對容易閱讀。</p>
<p>鑑於編譯出的 wasm 較長，下面我們只看我們關心的內容，
完整的內容可以看<a href="https://gist.github.com/quininer/53820dbf2bcadfca807aee1e9adb4865#file-wasm_stack_overflow_zero_bg-wat">這裏</a>。</p>
<p><code>wasm
(global (;0;) (mut i32) (i32.const 1050544))</code></p>
<p><code>global</code> 定義了一塊全局內存。其中一部分是數據段，剩下的 <code>1</code>MB 是棧空間。</p>
<p>```wasm
  (func $hash_with_key (type 2) (param i32 i32) (result i32)
    (local i32 i32 i32)
    get_global 0
    i32.const 32
    i32.sub</p>
<pre><code>;; ...

    get_local 2
    get_local 0
    i32.load16_u align=1
    i32.store16
    get_local 2
    get_local 0
    i32.const 2
    i32.add
    i32.load8_u
    i32.store8 offset=2

;; ...
</code></pre>
<p>)
```</p>
<p>函數 <code>hash_with_key</code> 在棧上開闢 <code>32</code>bytes，將 key 寫入棧上，退棧時未將其清零。</p>
<p>```wasm
  (func $table_index (type 4) (param i32) (result i32)
    (local i32)
    get_global 0
    i32.const 16
    i32.sub</p>
<pre><code>;; ...

i32.const 12
i32.add
get_local 0
i32.add
i32.load8_u)
</code></pre>
<p>```</p>
<p>函數 <code>table_index</code> 在棧上開闢 <code>16</code>bytes，偏移 <code>12</code>bytes 讀取。</p>
<p>在用戶正常調用 <code>hash_with_key(..)</code> 之後攻擊者調用 <code>table_index(16-12-32+x)</code> 便可獲得 key。</p>
<p><img alt="Read Stack Overflow" src="/upload/wasm-read-stack.png" /></p>
<hr />
<p>作者不熟悉二進制安全、計算機原理。胡言亂語不知所云，有錯勿怪。</p>]]></description><guid>https://quininer.github.io/?wasm-stack-overflow</guid><pubDate>Sun, 06 May 2018 12:42:20 -0000</pubDate></item><item><author>quininer kel</author><title>Stratis</title><link>https://quininer.github.io/?Stratis</link><description><![CDATA[<h1>Stratis</h1>
<h2><em>Sun Apr 15 18:14:39 2018</em></h2>
<p><a href="https://stratis-storage.github.io/">Stratis</a> 是 redhat 放棄 Btrfs 之後推出的代替品，
使用類似 LVM 的方案來提供有如 btrfs、zfs 般強大的功能。</p>
<p>其實 <a href="https://stratis-storage.github.io/">Stratis</a> 釋出 0.5 有一段時間了，今次抽出時間來嚐下鮮。
<a href="https://stratis-storage.github.io/">Stratis</a> 目前沒有面向用戶的文檔，故久違的寫一篇博文用以記錄。</p>
<h2>準備工作</h2>
<p>從 AUR 安裝 <a href="https://aur.archlinux.org/packages/stratisd/">stratisd</a>
同 <a href="https://aur.archlinux.org/packages/stratis-cli/">stratis-cli</a>，
然後啟動 stratisd</p>
<p><code>$ systemctl start stratisd</code></p>
<h2>開始</h2>
<p>首先我們清理要用的塊設備</p>
<p><code>$ sudo wipefs -a /dev/sda</code></p>
<p>但當前版本創建 pool 的時候會碰到錯誤，stratisd 認爲這個塊設備已經被使用</p>
<p><code>$ stratis pool create stratis /dev/sda
Execution failed: 1: Device /dev/sda appears to belong to another application</code></p>
<p>根據 <a href="https://github.com/stratis-storage/stratisd/issues/822#issuecomment-371585235">issue</a>，
如果塊設備的前 <code>4</code>/<code>8</code>k 字節未置零，stratisd 不會使用它。</p>
<p>知道原因就簡單了，我們將它置零</p>
<p><code>$ dd if=/dev/zero of=/dev/sda bs=1024 count=8</code></p>
<p>然後就可以正常創建 pool</p>
<p><code>$ stratis pool create stratis /dev/sda
$ stratis pool list
Name       Total Physical Size  Total Physical Used
stratis           &gt; 238.47 GiB               52 MiB</code></p>
<p>隨後創建 fs</p>
<p><code>$ stratis fs create stratis storage
$ stratis fs list stratis
Name
storage
$ la /dev/stratis/stratis/storage
Permissions Size User Date Modified Name
lrwxrwxrwx     9 root 15 4月  18:21 /dev/stratis/stratis/storage -&gt; /dev/dm-6</code></p>
<h2>完成</h2>
<p>創建完成，直接掛載就可以使用啦</p>
<p><code>$ sudo mount /dev/stratis/stratis/storage /run/media/quininer/storage
$ sudo chown quininer /run/media/quininer/storage</code></p>
<p>用得開心。 ;-)</p>]]></description><guid>https://quininer.github.io/?Stratis</guid><pubDate>Sun, 15 Apr 2018 16:27:40 -0000</pubDate></item><item><author>quininer kel</author><pubDate>Tue, 06 Oct 2015 06:49:18 -0000</pubDate><guid>https://quininer.github.io/?%E5%9F%BA%E4%BA%8EserviceWorker%E7%9A%84%E7%BC%93%E5%AD%98%E6%8A%95%E6%AF%92</guid><link>https://quininer.github.io/?%E5%9F%BA%E4%BA%8EserviceWorker%E7%9A%84%E7%BC%93%E5%AD%98%E6%8A%95%E6%AF%92</link><title>基于serviceWorker的缓存投毒</title><description><![CDATA[<h1>基于serviceWorker的缓存投毒</h1>
<h2><em>Sat May  2 20:52:57 2015</em></h2>
<p>前几天才察觉到 Chromium 42 已经支持 Fetch API 了，
鉴于我早就想用 Fetch 代替 Ajax，
所以今天把 ice.js 的<code>$.http</code>部分改用 Fetch <a href="https://github.com/quininer/quininer.github.io/commit/df932e8111e716a0813f6c3fa856d196626352a6">实现</a>了。</p>
<p>没想到的是 Firefox 目前还是 37 版本，不支持 Fetch。所以不得不引入一个 fetch.js 做兼容。</p>
<hr />
<h2>以上都不是重点</h2>
<p>和 Fetch 搭配使用的还有一个有趣的东西，<code>serviceWorker</code>。
其实早就在某牛的<a href="http://www.web-tinker.com/article/20879.html">博客</a>中看到过，
当时没有太深想，也因为没有实际上支持 Fetch 的浏览器，所以并没在意。</p>
<p>因为上文的事件，想起了这东西。
简单来说，这个API能拦截 HTTP Request，并返回预定的 Response。</p>
<p>自然，Response 里也包括 HTTP Headers，
所以只要简单的在 HTTP Header 里控制一下缓存时间即可，比如</p>
<pre><code>Cache-control: max-age=99999999999999999999999999999999999999
</code></pre>
<p>下面是一些截图</p>
<p><img alt="1" src="/upload/cache-tests-1.png" />
<img alt="2" src="/upload/cache-tests-2.png" />
<img alt="3" src="/upload/cache-tests-3.png" /></p>
<p>POC: <a href="https://quininer.github.io/tests/cache-tests/serviceworker/index.html">cache tests</a></p>
<p>实际上也并非所有 HTTP Header 都能使用，这里有一个<a href="https://fetch.spec.whatwg.org/#concept-header-list">禁表</a>。</p>
<hr />
<p>~~总之这套东西不管从哪方面来说都好方便。 :)~~</p>
<h2>实际上</h2>
<p>收回上一句话。
和<a href="https://twitter.com/filedescriptor">FD</a>测试了一会，
上面的POC看上去很美，实际上<code>serviceWorker</code>限制多多。</p>
<p>比如</p>
<ul>
<li>只能拦截<strong>同源</strong>且子路径的 Requests</li>
<li>scriptURL 必须<strong>同源</strong>，且 <a href="https://github.com/slightlyoff/ServiceWorker/issues/262">原则</a> 上必须是<strong>实际</strong>存在网络的资源</li>
<li><code>worker.js</code> 的处理和一般 script 处理不一样，必须<strong>符合</strong>规范，否则将会静默的失败</li>
<li><code>serviceWorker</code>只能工作在 <ruby>开发环境<rt>localhost</rt></ruby> 和 <a href="https://github.com/slightlyoff/ServiceWorker/issues/385">HTTPS</a> 下</li>
</ul>
<p>且不说要求 HTTPS 这样涉及协议的奇葩规定，
要求 scriptURL 必须实际存在这一点就让利用变得几无可能。</p>
<p>实际上使用也会变得极不方便，难以和各种完全由 JavaScript 生成的框架整合。
也没有实际上解决安全问题。</p>
<p>我倒是更希望 scriptURL 能允许使用 Blob，而<code>Cache</code>被加入 HTTP Header 禁表。</p>]]></description></item><item><pubDate>Tue, 21 Apr 2015 09:28:47 -0000</pubDate><link>https://quininer.github.io/?Surface</link><title>Surface</title><description><![CDATA[<h1>Surface Pro 3</h1>
<h2><em>Mon Mar 30 17:19:12 2015</em></h2>
<p><img alt="Surface Pro 3" src="/upload/surface.jpg" /></p>
<p>事情是這樣的，我買了一臺 Surface Pro 3，並給它裝了 Arch Linux。</p>
<h2>關於Windows</h2>
<p>用了兩天 Windows 8，其實感覺還不錯，按照之前的<a href="https://twitter.com/quininers/status/555389735594496003">想法</a>，
試圖裝上 <a href="http://gooseberrycreative.com/cmder/">Cmder</a> 和 <a href="https://msys2.github.io/">msys2</a> 來讓 Windows 上的終端也達到可用狀態。</p>
<p><a href="https://twitter.com/quininers/status/581435255137030144">效果</a>不盡人意，</p>
<ul>
<li>cmder 不知是字體或是什麼問題，Vim 下字符會混亂，有點像不等寬字體，而且還有鍵捕獲不到以及亂碼的奇怪問題</li>
<li>msys2 的包太少，完全不夠用</li>
<li>mingw 不會用= =</li>
<li>一開始 msys2 用 pacman 裝的 Mingw Python 找不到，需要手動把<code>/mingw64/bin</code>加入 PATH</li>
<li>試圖安裝上 yaourt，但是依賴的依賴 yajl 編譯報錯，似乎還要做許多設置</li>
</ul>
<p>雖然 Windows 的觸屏體驗確實很棒，但是我早有裝 Arch Linux 的想法。所以上面的問題只是藉口。</p>
<h2>關於Arch Linux</h2>
<p>自從 Debian 換成 Arch Linux 之後便很喜歡。</p>
<h3>Secure Boot</h3>
<p>開機時<code>音量鍵上 + 開機鍵</code>進 UEFI 關掉就好了，
雖然不關也能通過<a href="https://wiki.archlinux.org/index.php/Unified_Extensible_Firmware_Interface#Secure_Boot">這個方法</a>來啓動，
但是實際上安裝完成之後依然會提示錯誤。</p>
<h3>Install</h3>
<p>雖然 <a href="http://www.reddit.com/r/SurfaceLinux/">reddit</a> 上都說 WiFi 驅動在 3.19 內核才被合併，
但是被 #archlinux-cn 頻道的 Feb-Chip 告知親測 Arch Linux 目前 3.18 內核的鏡像也能直接使用。
livecd 裏的 tty 下不能使用 Type Cover 鍵盤(猜測 3.19 內核之後就可以了)，所以使用 SD卡 引導。
和 U盤 一樣，<code>音量鍵下 + 開機鍵</code>即可。</p>
<p>安裝過程完全參考<a href="https://wiki.archlinux.org/index.php/Beginners%27_guide">新手指南</a>，沒有碰上特殊問題。</p>
<h3>KDE</h3>
<p>HiDPI 依然按照 <a href="https://wiki.archlinux.org/index.php/HiDPI">wiki</a> 配置。</p>
<p>Firefox 效果不錯，
而<a href="https://twitter.com/quininers/status/582090512603033600">Chromium 效果糟糕</a>，<code>--force-device-scale-factor=2</code> 就像被直接放大，沒有任何優化。
比較好的方案是手動把網頁調到 175% 的大小。</p>
<p><a href="https://github.com/nuclearsandwich/surface3-archlinux/issues/8">電磁筆</a>和觸屏幾乎完美。可惜沒有什麼對觸屏有優化的應用。
這一點 Chromium 做的比 Firefox 好。
配置一下可以讓電磁筆的<a href="https://github.com/nuclearsandwich/surface3-archlinux/issues/4#issuecomment-68158518">按鈕</a>起些作用。</p>
<p>當然 Type Cover 也要<a href="https://github.com/nuclearsandwich/surface3-archlinux/issues/4#issuecomment-62277004">配置</a>。~~不過我碰到了一些問題，
一旦碰到 Type Cover 的觸摸板，X 便段錯誤崩潰了。
我沒有找到類似的案例，推測是個例。~~</p>
<p>此問題已解決，更新 linux-surfacepro3 內核時重新配置了一下 <code>/etc/X11/xorg.conf.d/50-synaptics.conf</code>，觸摸板使用正常~</p>
<h3>Kernel</h3>
<p>編譯 aur 裏的 <a href="https://aur.archlinux.org/packages/linux-surfacepro3/">linux-surfacepro3</a> 內核，
最主要的是打上了電源補丁，終於可以看到電量了。</p>
<p>装内核時碰上一個坑，/tmp 掛載的大小只有 2G，因爲之前從 aur 打包了幾個軟件而內核又很大，
所以打包 linux-surfacepro3 時塞滿了 /tmp，導致打包失敗。
編譯了兩次之後才發覺..
默默修改 /etc/yaourtrc 中的<code>TMPDIR</code>，</p>
<pre><code>TMPDIR="$HOME/Aurs"
</code></pre>
<h3>Battery</h3>
<p>在 Windows 下粗略計過一下續航，<ruby>平常使用<rt>瀏覽網頁</rt></ruby>確實能有 8h 之長。
換到 Linux 之後，用秒錶計算，提示 10% 的電量時，续航 4:29:59 。其中包括 40m- 的 FEZ 遊戲時間。</p>
<p>估計用 <a href="https://wiki.archlinux.org/index.php/Laptop_Mode_Tools">laptop-mode</a> 之類的動態調頻能延長一些續航。</p>
<p>最後，編譯 YCM 只用了 2分8秒，而上一個筆記本需要 5分鐘 左右。</p>
<hr />
<p>寫完博客第二天 linux-surfacepro3 就<a href="https://github.com/matthewwardrop/linux-surfacepro3">更新</a>了，不得不再編譯一次內核。
過程順利。</p>
<p>順便找到一個<a href="https://github.com/AykoPoel/surface3-scripts">自动旋转脚本</a>，雖然不夠流暢，但也可用。</p>
<p>剩下唯一的問題就是 KDE 缺少一個好用的屏幕鍵盤了吧。</p>
<hr />
<p>在 Laptop-mode 下測試，正常使用至 10% 電量，續航 6:21:40。</p>
<h2>參考</h2>
<ul>
<li><a href="https://wiki.archlinux.org/index.php/Unified_Extensible_Firmware_Interface#Secure_Boot">Unified Extensible Firmware Interface - Secure Boot</a></li>
<li><a href="https://wiki.archlinux.org/index.php/Beginners%27_guide">Beginners' guide</a></li>
<li><a href="https://wiki.archlinux.org/index.php/HiDPI">HiDPI</a></li>
<li><a href="https://github.com/nuclearsandwich/surface3-archlinux/issues/8">N-Trig Touch Pen - Works great but I have no idea how to configure it!</a></li>
<li><a href="https://github.com/nuclearsandwich/surface3-archlinux/issues/4">Type Cover 3 not working even after kernel patch</a></li>
<li><a href="https://aur.archlinux.org/packages/linux-surfacepro3/">aur - linux-surfacepro3</a></li>
<li><a href="https://wiki.archlinux.org/index.php/Laptop_Mode_Tools">Laptop_Mode_Tools</a></li>
<li><a href="https://github.com/matthewwardrop/linux-surfacepro3">github - linux-surfacepro3</a></li>
<li><a href="https://github.com/AykoPoel/surface3-scripts">Surface3-Scripts - autorotate.py</a></li>
</ul>]]></description><guid>https://quininer.github.io/?Surface</guid><author>quininer kel</author></item><item><pubDate>Tue, 21 Apr 2015 09:28:37 -0000</pubDate><description><![CDATA[<h1>Google-Cloud-Security-Scanner</h1>
<h2><em>Thu Mar  5 14:12:39 2015</em></h2>
<p>一回来上推就看到个有趣的东西——<a href="https://twitter.com/paradoxengine/status/568436963960877056">Google Cloud Security Scanner</a>，
虽然目前只是Beta，主要只有XSS检测和分析功能，不过怎么说也是<strong>Google</strong>出品。</p>
<p><a href="https://cloud.google.com/tools/security-scanner/"><img alt="" src="/upload/gcsscan.png" /></a></p>
<p>亲测一番效果一般，可以选择前端测试环境。
有一点比较麻烦，目前只允许扫描自己有权限的Gae应用。
不过只要用Gae做个Proxy应用就能随意扫了。</p>
<p>没有太大亮点。不过比上不足比下有余，比起市面上大部份云扫描器算是好得多了。</p>
<hr />
<p>其实用<code>asyncio</code>写了半个Proxy应用来着，才反应过来Gae没有<code>Python 3.4</code>。
在Github里找了个<a href="https://github.com/kitek/GAE-http-proxy">成品</a>，效果不错。</p>]]></description><link>https://quininer.github.io/?Google-Cloud-Security-Scanner</link><title>Google-Cloud-Security-Scanner</title><guid>https://quininer.github.io/?Google-Cloud-Security-Scanner</guid><author>quininer kel</author></item><item><description><![CDATA[<h1>关于expressjs的一个小坑</h1>
<h2><em>Tue Dec  9 01:07:53 2014</em></h2>
<p>都知道在PHP里，<code>/?key[arr]=value</code> 会被解析为</p>
<pre><code>array(1) { ["key"]=&gt; array(1) { ["arr"]=&gt; string(5) "value" } }
</code></pre>
<p>却一直没注意到expressjs里也会如此，</p>
<pre><code>// GET /shoes?order=desc&amp;shoe[color]=blue&amp;shoe[type]=converse
req.query.order
// =&gt; "desc"

req.query.shoe.color
// =&gt; "blue"

req.query.shoe.type
// =&gt; "converse"
</code></pre>
<p>而在<a href="http://expressjs.com/4x/api.html#req.query">req.query</a>里仅仅是这样不太显眼的一笔带过，似乎嵌套解析已成标配。
但是不得不说的是嵌套解析至少在Node.js里很危险。</p>
<p>例如</p>
<pre><code>app.get('/', function(req, res){
    sql.find({_id:req.query.id})
    .exec(function(err, data){
        res.json({data:data});
    });
});
</code></pre>
<p>访问<code>/?id[$ne]=1</code>则会返回不该有的数据，正如<a href="http://drops.wooyun.org/tips/3939">这里</a>。</p>
<p>当然这不是mongodb的问题，参数的属性也可能被劫持</p>
<pre><code>app.get('/', function(req, res){
    if(req.query.name.length &lt;= 5){
        // TODO
        res.json({'err':null, 'name':req.query.name});
    }else{
        res.json({'err':'名字过长！'});
    };
});
</code></pre>
<p>使用<code>/?name[length]=1</code>即能绕过这个名字长度的限制。</p>
<p>同样的利用方法在更奇怪的环境可能会造成更严重的后果，最终导致<strong>code injection</strong>也并非不可能。<br />
大概是意识到了这点，开发团队在下一个Web框架<a href="http://koajs.com/#request-query">koa</a>里取消了对嵌套解析的支持。<br />
后续分离的<a href="https://github.com/expressjs/cookie-parser">cookie-parser</a>也不支持嵌套解析。</p>
<p>最后，我的粗略的解决方案是</p>
<pre><code>app.get('/', function(req, res){
    var name = (typeof req.query.name == 'string')?req.query.name:undefined;
    // TODO
});
</code></pre>
<p>或是使用中间件</p>
<pre><code>app.use(function(req, res, next){
    for(var i in req.query)if(typeof req.query[i] != 'string')delete req.query[i];
    for(var i in req.body)if(typeof req.body[i] != 'string')req.body[i] = JSON.stringify(req.body[i]);
    next();
});
</code></pre>
<hr />
<p><strong>总之，务必先验证<code>req.query.name</code>，<code>req.body.name</code>以及<code>req.param('name')</code>的类型</strong></p>]]></description><author>quininer kel</author><pubDate>Tue, 21 Apr 2015 09:28:15 -0000</pubDate><link>https://quininer.github.io/?%E5%85%B3%E4%BA%8Eexpressjs%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9D%91</link><title>关于expressjs的一个小坑</title><guid>https://quininer.github.io/?%E5%85%B3%E4%BA%8Eexpressjs%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9D%91</guid></item><item><author>quininer kel</author><pubDate>Tue, 21 Apr 2015 09:27:02 -0000</pubDate><title>ArriettySong</title><link>https://quininer.github.io/?ArriettySong</link><guid>https://quininer.github.io/?ArriettySong</guid><description><![CDATA[<h1>Arrietty'sSong</h1>
<h2><em>Sun Sep 21 17:20:47 2014</em></h2>
<p><img alt="“Karigurashi”作者Studio Ghibli - 官方网站。来自Wikipedia - http://zh.wikipedia.org/wiki/File:Karigurashi.jpg#mediaviewer/File:Karigurashi.jpg" src="https://upload.wikimedia.org/wikipedia/zh/3/38/Karigurashi.jpg" />
<audio src="https://www.dropbox.com/s/qqxsp3nvw3gvaea/Arrietty%27s%20Song.mp3?dl=1" autoplay type="audio/mpeg"></p>]]></description></item></channel>
</rss>
